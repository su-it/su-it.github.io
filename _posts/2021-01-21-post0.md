---
title:  "JAVA 정리"
excerpt: "자바 복습용 정리(매일 아침 10분)"

#categories:  - Blog
#tags:  - Blog
last_modified_at: 2021-01-21
      
---
# JAVA

## 01. 자바 

- 자바의 특징
  : OS 독립적, 객체지향, Garbage Collector, 멀티쓰레드 등 
- 객체지향 특징
  : 캡슐화(불필요한 접근 제한), 상속, 추상화(공통 기능 및 속성), 다형성  
- 다형성
  : "여러 형태를 가진다는 뜻으로, 한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있도록 하는 것 
  (인터페이스와 상속으로 가능하다)  
- JVM: Wirte once, run anywhere  





*****

## 02. 변수

변수

* 변수: "값을 저장하는 공간"
* 초기화: "제일 처음 값을 저장"
* 명명규칙: _, $



변수의 종류

* 논리형: boolean(1)
* 문자형: char(2) // 유니코드
* 정수형: byte(1), short(2), int(4), long(8) // byte 이진 표현, short c호환, int 20억
* 실수형: float(4), double(8) // 7자리, 15자리



상수와 리터럴

* 구분자: 정수형 리터럴 중간에 사용 가능(1.7 이후) // long big = 100_000_000L;
* 접미사: long(l, L), flaot(f, F), dobule(d, D)
* 제곱: e // 1e1 = 10.0; 1e-3 = 0.001;



printf()

* 지시자: %d(10), %c(char), %s(string), %f(실수, floating-point), %e(지수), %g(간략), %b(boolean), %o(8), %x(16)
* 길이&정렬: %3d( XX, 최소 3글자 출력 및 우측정렬), %-3d(XX ), %03d(0XX), %.n(x,왼쪽에서 n글자만 출력)
* #: 접두사 %#x(0xff), %#o(0oo), %#X(0XFF)
* 10→2진수: Integer.toBinaryString(int i) // 2진수로 변환해서 문자열로 반환



기본형

* 진법: 10진수 n자리 = 2ⁿ / 8진수 1자리 = 2진수 3자리 / 16진수 1자리 = 2진수 4자리
* 특수문자: \t \n \\ \' \" \n(다음 행으로 줄바꿈) \r(행의 처음으로 이동) \f(인쇄 페이지 바꾸기)
* 유니코드: A-65, a-97, 0-48    (유니코드는 아스키코드를 포함한다) 
  // 소문자 -32 = 대문자 (단, char와 int 뺄셈 결과는 int이므로 char로 형변환 필요)
* 정수형 오버플로우: "해당 타입이 표현할 수 있는 값의 범위를 넘어서 0이 됨"
  실수형 오버플로우: 무한대 / 언더플로우: 0
* float→int: Float.floatToIntBits(float f) 
* float로 변환시, 범위를 넘으면 무한대 또는 0이 됨



## 03. 연산자

- 증감연산자
  : ++i 전위형(값 참조 전에 증가), i++ 후위형(값 참조 후에 증가)
  // j = ++i는 ++i 후에 j = i한 것과 같음

  

- 산술연산자
  -정수형은 0으로 나누면 에러(ArithmeticException)
  -실수형으로 바꾸고 나누기
  -상수 또는 리터럴 간의 연산은 컴파일 시에 컴파일러가 계산해서 결과로 값을 대체함

  |  **x**   |  **y**   | **x/y**  | **x%y** |
  | :------: | :------: | :------: | :-----: |
  |  유한수  |    0     | Infinity |   NaN   |
  |  유한수  | Infinity |    0     |    x    |
  |    0     |    0     |   NaN    |   NaN   |
  | Infinity |  유한수  | Infinity |   NaN   |
  | Infinity | Infinity |   NaN    |   NaN   |

- 비교연산자

  -실수형은 근사값으로 저장되므로 오차 발생 가능
  -문자열의 비교 equals() 또는 equalsIgnoreCase()

- 논리연산자

  -같은 조건식이어도 피연산자 위치에 따라 연산속도가 달라짐

- 비트연산자

  -| : OR, 특정 비트 값을 변경 
  (10101011 | 00001111 = 10101111)
  -& : AND, 특정 비트 값을 추출 
  (10101011 & 00001111 = 00001011)
  -^ : XOR, 원래의 값으로 복원(암호화)
  (10101011 ^ 00001111 = 10100100, 	10100100 ^ 000011111 = 10101011)








Math.round() 반올림

Math.PI  

